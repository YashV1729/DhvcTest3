let ANNOTATIONDATA = {}; let HOTSPOTSDATA = {}; let myMinMaxTheta = []; let myMinMaxDist = []; let typeHs = "Sphere"; let urlHS = "models/sphere.ply"; let xmlhttp = new XMLHttpRequest(); xmlhttp.onreadystatechange = function() { if (this.readyState ==
4 && this.status == 200) { let myObj = JSON.parse(this.responseText); ANNOTATIONDATA = myObj; } }; xmlhttp.open("GET", "js/bewcastle.json", false); xmlhttp.send(); //*********************************************************************************************************************
let xmlhttp = new XMLHttpRequest(); xmlhttp.onreadystatechange = function() { if (this.readyState == 4 && this.status == 200) { let myObj = JSON.parse(this.responseText); HOTSPOTSDATA = myObj; } }; xmlhttp.open("GET", "js/bewcastle_hotspots.json", false);
xmlhttp.send(); //**************************** Start setting datas from json **************************** // Model data myMinMaxTheta.push(ANNOTATIONDATA.minMaxTheta[0], ANNOTATIONDATA.minMaxTheta[1]); myMinMaxDist.push(ANNOTATIONDATA.minMaxDist[0], ANNOTATIONDATA.minMaxDist[1]);
// Start hotspots data let cont = {}; for (let ii = 0; ii
< HOTSPOTSDATA.annotations.length; ii++) { let pos=H OTSPOTSDATA.annotations[ii].position let radius=H OTSPOTSDATA.annotations[ii].radius; let newSpot={ mesh: typeHs, color: [0.0, 0.25, 1.0], transform: { matrix: SglMat4.mul(SglMat4.translation(pos),
    SglMat4.scaling([radius, radius, radius])) }, }; cont[HOTSPOTSDATA.annotations[ii].name]=n ewSpot; } // End hotspots data function actionsToolbar(action) { if (action=='home' ) presenter.resetTrackball(); else if (action=='zoomin' ) presenter.zoomIn();
    else if (action=='zoomout' ) presenter.zoomOut(); else if (action=='lighting' || action=='lighting_off' ) { if (action=='lighting' ) { lightSwitchL( 'light_off'); } presenter.enableSceneLighting(!presenter.isSceneLightingEnabled()); lightingSwitch();
    } else if (action=='light' || action=='light_off' ) lightSwitchL(action); //--COLOR-- else if (action=='color' || action=='color_on' ) { presenter.toggleInstanceSolidColor(HOP_ALL, true); colorSwitch(); } //--COLOR-- else if (action=='hotspot' || action=='hotspot_on'
    ) { presenter.toggleSpotVisibility(HOP_ALL, true); presenter.enableOnHover(!presenter.isOnHoverEnabled()); hotspotSwitch(); } else if (action=='measure' || action=='measure_on' ) { presenter.enableMeasurementTool(!presenter.isMeasurementToolEnabled());
    measureSwitch(); } else if (action=='screenshot' ) presenter.saveScreenshot(); else if (action=='full_on' || action=='full' ) { fullscreenSwitch(); } else if (action=='move_up' || action=='move_down' || action=='move_right' || action=='move_left' ) step(action);
    else if (action=='Top' ) presenter.animateToTrackballPosition(ANNOTATIONDATA.cardinalP[action]); else if (action=='info' ) infoClick(); } //**************************** Start manager of arrows movements **************************** function step(action)
    { let my_pos=[ ]; let vstep=0 .1; let hstep=0 .1; my_pos=p resenter.getTrackballPosition(); switch (action) { case 'move_up': my_pos[3] -=v step; presenter.animateToTrackballPosition(my_pos); break; case 'move_down': my_pos[3] +=v step; presenter.animateToTrackballPosition(my_pos);
    break; case 'move_right': var gr=M ath.PI * my_pos[0] / 180; // from degrees to radians my_pos[2] -=0 .1 * Math.cos(gr); my_pos[4] +=0 .1 * Math.sin(gr); presenter.animateToTrackballPosition(my_pos); break; case 'move_left': var gr=M ath.PI * my_pos[0]
/ 180; // from degrees to radians my_pos[2] +=0 .1 * Math.cos(gr); my_pos[4] -=0 .1 * Math.sin(gr); presenter.animateToTrackballPosition(my_pos); break; } } //**************************** End manager of arrows movements **************************** //*****************************
    Menage the click on info button *************************** function infoClick() { if ($( 'iframe').css( "visibility")=="visible" ) { $( 'iframe').css( "visibility", "hidden"); } else { $( 'iframe').css( "visibility", "visible"); } } //*****************************************************************************************
//------------------------------------------- function compassClick(event) { let dirX=( event.offsetX - (event.srcElement.width / 2.0)) / event.srcElement.width; let dirY=( event.offsetY - (event.srcElement.height / 2.0)) / event.srcElement.height; let
    len=M ath.sqrt((dirX * dirX) + (dirY * dirY)); dirX=d irX / len; dirY=d irY / len; let targetA=s glRadToDeg(Math.atan2(dirX, dirY)); let currpos=p resenter.getTrackballPosition(); targetA=c urrpos[0] + targetA; targetA=t argetA < 0 ? ((targetA % 360)
    + 360) : (targetA % 360); targetA=M ath.floor((targetA + 45) / 90.0) * 90.0; currpos[0]=t argetA presenter.animateToTrackballPosition(currpos); } //------------------------------------------- //**************************** Manages the lightcontroller
    **************************** function lightSwitchL(status) { if (status=='light' ) { $( '#light').css( "visibility", "hidden"); $( '#light_off').css( "visibility", "visible"); $( '#lighting_off').css( "visibility", "hidden"); //manage lighting combined
    interface $( '#lighting').css( "visibility", "visible"); //manage lighting combined interface $( '#lightcontroller').css( 'right', 14 + "%"); $( '#lightcontroller').css( 'left', "auto"); $( '#lightcontroller').css( 'top', ($( '#right_tolbar').position().top
    + $( '#right_tolbar').width() + 250)); presenter.enableSceneLighting( 'lighting_off'); lightingSwitch( 'lighting_off'); } else { $( '#light_off').css( "visibility", "hidden"); $( '#light').css( "visibility", "visible"); $( '#lightcontroller').css(
    'top', ($( '#toolbar').position().top - 250)); //manages the lightcontroller when it disappears } } //**************************** Start functions that make lightController work **************************** function click_lightcontroller(event) { let XX=0
    , YY=0 ; let midpoint=[ 63, 63]; let radius=6 0; let lightControllerCanvas=d ocument.getElementById( "lightcontroller_canvas"); let coords=l ightControllerCanvas.relMouseCoords(event); XX=c oords.x - midpoint[0]; YY=c oords.y - midpoint[1]; // check inside
    circle if ((XX * XX + YY * YY) < ((radius - 5) * (radius - 5))) { let lx=( XX / radius) / 2.0; let ly=( YY / radius) / 2.0; presenter.rotateLight(lx, -1.0 * ly); // inverted ly update_lightcontroller(lx, ly); (event.touches) ? lightControllerCanvas.addEventListener(
    "touchmove", drag_lightcontroller, false): lightControllerCanvas.addEventListener( "mousemove", drag_lightcontroller, false); } } function drag_lightcontroller(event) { let XX=0 , YY=0 ; let midpoint=[ 63, 63]; let radius=6 0; let lightControllerCanvas=d ocument.getElementById(
    "lightcontroller_canvas"); let coords=l ightControllerCanvas.relMouseCoords(event); XX=c oords.x - midpoint[0]; YY=c oords.y - midpoint[1]; // check inside circle if ((XX * XX + YY * YY) < ((radius - 5) * (radius - 5))) { let lx=( XX / radius) / 2.0; let ly=( YY / radius) /
    2.0; presenter.rotateLight(lx, -1.0 * ly); // inverted ly update_lightcontroller(lx, ly); } } function update_lightcontroller(xx, yy) { let midpoint=[ 63, 63]; let radius=6 0; let lightControllerCanvas=d ocument.getElementById(
    "lightcontroller_canvas"); let context=l ightControllerCanvas.getContext( "2d"); context.clearRect(0, 0, lightControllerCanvas.width, lightControllerCanvas.height); context.beginPath(); context.arc(midpoint[0], midpoint[1], radius, 0, 2 * Math.PI, false); let grd=c ontext.createRadialGradient(midpoint[0]
    + (xx * radius * 2), midpoint[1] + (yy * radius * 2), 5, midpoint[0], midpoint[1], radius); grd.addColorStop(0, "#f8f8f8"); grd.addColorStop(1, "black"); context.fillStyle=g rd; context.fill(); context.lineWidth=3 ; context.strokeStyle='black' ; context.stroke();
    context.beginPath(); context.rect(midpoint[0] + (xx * radius * 2) - 3, midpoint[1] + (yy * radius * 2) - 3, 5, 5); context.lineWidth=2 ; context.strokeStyle='yellow' ; context.stroke(); //presenter.ui.postDrawEvent(); } function relMouseCoords(event)
    { let totalOffsetX=0 ; let totalOffsetY=0 ; let canvasX=0 ; let canvasY=0 ; let pageX=0 ; let pageY=0 ; let currentElement=t his; do { totalOffsetX +=c urrentElement.offsetLeft - currentElement.scrollLeft; totalOffsetY +=c urrentElement.offsetTop - currentElement.scrollTop;
    } while (currentElement=c urrentElement.offsetParent) (event.touches) ? (pageX=e vent.touches[0].pageX) : (pageX=e vent.pageX); (event.touches) ? (pageY=e vent.touches[0].pageY) : (pageY=e vent.pageY); canvasX=p ageX - totalOffsetX; canvasY=p ageY - totalOffsetY;
    return { x: canvasX, y: canvasY } } HTMLCanvasElement.prototype.relMouseCoords=r elMouseCoords; //**************************** End lightControler functions **************************** //****************************** Start ConvertToGlobal/Local coordinates
    taken from SPOTMAKER. ****************************** //****************************** Transform coordinates from global to local and viceversa. ****************************** function convertToGlobal(state) { let newstate=[ ]; // angles newstate[0]=s
    tate[0]; newstate[1]=s tate[1]; // pan newstate[2]=( state[2] / presenter.sceneRadiusInv) + presenter.sceneCenter[0]; newstate[3]=( state[3] / presenter.sceneRadiusInv) + presenter.sceneCenter[1]; newstate[4]=( state[4] / presenter.sceneRadiusInv) + presenter.sceneCenter[2];
// distance newstate[5]=s tate[5] / presenter.sceneRadiusInv; return newstate; } function convertToLocal(state) { let newstate=[ ]; // angles newstate[0]=s tate[0]; newstate[1]=s tate[1]; // pan newstate[2]=( state[2] - presenter.sceneCenter[0]) * presenter.sceneRadiusInv;
    newstate[3]=( state[3] - presenter.sceneCenter[1]) * presenter.sceneRadiusInv; newstate[4]=( state[4] - presenter.sceneCenter[2]) * presenter.sceneRadiusInv; // distance // (state[5] * presenter.sceneRadiusInv) --> coordinate from SPOTMAKER // start --> my startDistance // 2 --> SPOTMAKER start distance newstate[5] = (state[5] * presenter.sceneRadiusInv) * ANNOTATIONDATA.start / 2; return newstate; } //****************************** End ConvertToGlobal/Local ******************************
    //****************************** Original version of the funcion ********************************************** function convertToLocal_or(state) { let newstate = []; // angles newstate[0] = state[0]; newstate[1] = state[1]; // pan newstate[2] = (state[2]
    - presenter.sceneCenter[0]) * presenter.sceneRadiusInv; newstate[3] = (state[3] - presenter.sceneCenter[1]) * presenter.sceneRadiusInv; newstate[4] = (state[4] - presenter.sceneCenter[2]) * presenter.sceneRadiusInv; // distance newstate[5] = state[5]
    * presenter.sceneRadiusInv; return newstate; } //************************************************************************************************************** //*********************************** Start hotspots f() ***********************************
    function onPickedSpot(id) { for (let ii = 0; ii
    < HOTSPOTSDATA.annotations.length; ii++) { let view=H OTSPOTSDATA.annotations[ii].view; if (HOTSPOTSDATA.annotations[ii].name==i d) { presenter.animateToTrackballPosition(convertToLocal(view)); } } } //*********************************** End hotspots
        f() *********************************** function onEndMeasure(measure) { // measure.toFixed(2) sets the number of decimals when displaying the measure // depending on the model measure units, use "mm", "m", "km" or whatever you have $(
        '#measure-output').html(measure.toFixed(2) + " mm"); } let presenter=n ull; function setup3dhop() { presenter=n ew Presenter( "draw-canvas"); let myScene; myscene={ meshes: {}, modelInstances: {}, spots: {}, trackball: {}, space: {} }; //***********************************
        Start passage of data for settings *********************************** myscene.meshes[ANNOTATIONDATA.name]={ url: ANNOTATIONDATA.url }; myscene.meshes[typeHs]={ url: urlHS }; // Here I declare the sphere myscene.modelInstances[ANNOTATIONDATA.mdI]={
        mesh: ANNOTATIONDATA.name, color: [0.6, 0.5, 0.55] }; myscene.spots=c ont; myscene.trackball={ type: TurntablePanTrackball }; myscene.trackball.trackOptions={ startPhi: 0.0, startTheta: 0.0, startDistance: ANNOTATIONDATA.start, minMaxPhi: [-180, 180],
        minMaxTheta: myMinMaxTheta, // [-80.0,80.0] // Theta adjusts how much I can turn (low - high) the model about a central axis minMaxDist: myMinMaxDist, // [2.5,3.0] startPanX: ANNOTATIONDATA.PanX, startPanY: 0.0, startPanZ: 0.0, minMaxPanX: [-0.5,
        0.5], minMaxPanY: [-0.6, 0.6], minMaxPanZ: [-0.3, 0.3] }; myscene.space={ centerMode: "scene", radiusMode: "scene", cameraFOV: 60.0, cameraNearFar: [0.01, 10.0], cameraType: "perspective", sceneLighting: true }; //***********************************
        End passage of data for settings *********************************** // Assign myscene values to presenter presenter.setScene(myscene); /* Start hotspots (the rest of the added code is spots above) */ presenter.setSpotVisibility(HOP_ALL, false, true);
        presenter._onPickedSpot=o nPickedSpot; /* End hotspots */ presenter._onEndMeasurement=o nEndMeasure; } //**************************** Start COMPASS **************************** function onTrackballUpdate(trackState) { updateCompass(sglDegToRad(trackState[0]),
        sglDegToRad(trackState[1])); } function updateCompass(angle, tilt) { $( '#compassCanvas').attr( 'width', 145); $( '#compassCanvas').attr( 'height', 145); $( '#compassCanvas').css( 'border-radius', 80); let canv=d ocument.getElementById(
        "compassCanvas"); let ctx=c anv.getContext( "2d"); let hh=c anv.height; let ww=c anv.width; ctx.clearRect(0, 0, canv.width, canv.height); // Save the current drawing state ctx.save(); // Now move across and down half the ctx.translate(ww / 2.0, hh / 2.0); // Rotate
        around this point ctx.rotate(angle); ctx.beginPath(); ctx.lineWidth=1 ; // Change the thickness of the cardinal points // ctx.arc(0, 0, 45, 0, 2 * Math.PI, false); // With the commented part underneath, create an inner circumference // ctx.strokeStyle='#443377'
        ; // ctx.stroke(); ctx.font="40px Verdana" ; ctx.strokeStyle='#ff4444' ; ctx.strokeText( "N", -13, -29); ctx.strokeStyle='#ffffff' ; ctx.strokeText( "S", -12, 55); ctx.strokeText( "E", 35, 13); ctx.strokeText( "W", -60, 13); // Restore the previous
        drawing state ctx.restore(); } //**************************** End COMPASS **************************** //********************************************************************************************************************* $(document).ready(function()
        { // **************************** Start lightController *********************************** let lightControllerCanvas=d ocument.getElementById( "lightcontroller_canvas"); lightControllerCanvas.addEventListener( "touchstart", click_lightcontroller,
        false); lightControllerCanvas.addEventListener( "mousedown", click_lightcontroller, false); let canvas=d ocument.getElementById( "draw-canvas"); canvas.addEventListener( "mouseup", function() { lightControllerCanvas.removeEventListener(
        "mousemove", drag_lightcontroller, false); lightControllerCanvas.removeEventListener( "touchmove", drag_lightcontroller, false); }, false); document.addEventListener( "mouseup", function() { lightControllerCanvas.removeEventListener( "mousemove", drag_lightcontroller,
        false); lightControllerCanvas.removeEventListener( "touchmove", drag_lightcontroller, false); }, false); //----------------------------------- update_lightcontroller(-0.17, -0.17); // **************************** End lightController ***********************************
        init3dhop(); setup3dhop(); }); // onload occurs when all content has been loaded //window.onload=s etup3dhop;